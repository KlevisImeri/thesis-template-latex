\chapter{Background}

\section{Model Checking}
Model checking is a formal verification technique that 
systematically explores all possible states and transitions (the state space) of a formal model 
(representation) of the system to determine if it satisfies a formally specified property~\cite{HandbookMC}~\cite{Akos} .
This process typically involves:

\begin{algorithm}
\caption{Model Checking Reachability}
\begin{algorithmic}
\State Let $q :=$ desired state to reach
\State Let $Q :=$ set of initial states
\While{$q \notin Q$ and not all states visited}
  \State $Q \gets Q \cup \text{Tran}(Q)$
\EndWhile
\end{algorithmic}
\end{algorithm}

% - Q = {inicial states}
% - Tran: Q -> Q' := transition fucntion
% The alogrithm looks soemthin liek this:
% let q := the desired state to reach
% let Q  := {inicial states}
% whiel(q \in Q  or all states are visited) { 
%   Q = tran(Q)
% }



\section{Witnesses}
\label{sec:witnesses}
Verifier tools analyze a program along with a safety property and other specifications, ultimately
generating a result and supplementary details that support this result. This extra information, 
known as a witness, is structured according to a defined and widely recognized format, enabling 
compatibility across numerous tools. The initial proposed format for witnesses was Witness 1.0, which 
utilized GraphML~\cite{witness1}. Presently, the most recent proposed witness format is Witness 2.0, 
which employs YAML~\cite{witness2}.

The structure of 2.0 witnesses is syntactically defined by three key components:
\begin{itemize}
  \item \texttt{entry\_type} – the type of the witness ("violation\_sequence" or "invariant\_set")
  \item \texttt{metadata} – metadata about the witness
  \item \texttt{content} – content that varies depending on the type of witness
\end{itemize}

There are two categories of witnesses:

\begin{itemize}
  \item \textbf{Violation Witnesses (Counterexamples)}~\cite{witness2}~\cite{ViolationWitnessSchema} \\
  These are generated when the verifier finds that a safety property has been violated. 
  They provide a vaguely define program path illustrating how the violation is achieved. 
  The content comprises a sequence of segments, with a final segment at the end.

  Each segment contains \textit{waypoints}, which are specific program locations the execution passes through.
  A segment consists of any number of avoid waypoints, and it concludes with a single
  follow waypoint signalling the segment's end.
  A waypoint includes:
  \begin{itemize}
    \item \texttt{type} – such as \texttt{assumption}, \texttt{branching}, \texttt{target}, \texttt{function\_enter}, or \texttt{function\_return}
    \item \texttt{constraint} – describes the program state or path condition
    \item \texttt{location} – maps to a line in the source code
    \item \texttt{action} – specifies whether to avoid or pass through this waypoint
  \end{itemize}

  \item \textbf{Correctness Witnesses}~\cite{witness2}~\cite{CorrectnesWitnessSchema}\\
  These are produced when the verifier proves the program satisfies its specification. 
  The content consists of \textit{invariant elements}, each of which contains:
  \begin{itemize}
    \item \texttt{type} – either a loop or location invariant
    \item \texttt{location} – same as above
    \item \texttt{value} – the invariant expressed in the format specified
    \item \texttt{format} – the format of the invariant expression 
  \end{itemize}
\end{itemize}

\begin{figure}[h]
  \centering
  \includegraphics[width=1\textwidth]{figures/verifier.png}
  \caption{Verification}
  \label{fig:Verification}
\end{figure}

% ---
% config:
%       theme: redux
% ---

% flowchart LR
%   subgraph Verification Task
%     Program[Program]
%     Specification[Specification]
%   end

%   Program --> Verifier
%   Specification --> Verifier

%   Verifier -->|False : Bug found| ViolationWitness[Violation Witness]
%   {Verifier -->|True : Proof found| CorrectnessWitness[Correctness Witness]}
  
\section{Witness-based Result Validation}
Witnesses generated by different tools are typically cross-checked to ensure accuracy. 
A witness, being structured data in a standard format, facilitates faster result validation
across various tools compared to a complete reverification. While verification and validation 
are often confused, validation specifically relies on a witness, which offers additional 
information about the program's verification process~\cite{witness2}~\cite{witness1}. 
Witnesses accelerate this process by 
providing precomputed verification data. Furthermore, they enable the validation of results 
obtained from other tools.

\begin{figure}[h]
  \centering
  \includegraphics[width=0.8\textwidth]{figures/validator.png}
  \caption{Validation}
  \label{fig:Validation}
\end{figure}

% ---
% config:
%   theme: redux
%   layout: dagre
% ---
% flowchart LR
%  subgraph subGraph0["Verification Task"]
%         P("Program")
%         S("Specification")
%   end
%     W("Witness") --> V["Validator"]
%     P --> V
%     S --> V
%     V --> C("Valid/Unvalid")

\section{CFA}

To perform model checking, a program written in source code must first be transformed into a formal model. 
The formal model used in the Theta validator built is an Control-Flow Automaton (CFA).

\begin{definition}[Control-flow automata] Let:
\begin{itemize}
  \item $v :=$ variable
  \item $D_v :=$ domain of variable $v$
  \item $\varphi$ is an expression $\Rightarrow \mathrm{var}(\varphi) = \{\forall v \mid v \in \varphi\}$
  \item $\text{predicate} := p: D_{v_i} \times \dots \times D_{v_n} \to \{\text{true}, \text{false}\}$
\end{itemize}
A control-flow automaton is a tuple $\mathrm{CFA} = (V, L, l_0, E)$ where:
\begin{itemize}
  \item $V := \{v_1, \dots, v_n \mid \mathrm{domain}(v_i) = D_{v_i} \}$
  \item $L := \{$program locations modeling the program counter$\}$
  \item $l_0 \in L :=$ initial program location
  \item $E \subseteq L \times \mathrm{Ops} \times L := \{$directed edges representing operations$\}$
  \item $\mathrm{Ops} = \{ \mathrm{op} \mid \mathrm{op} = \text{assignment} \lor \mathrm{op} = \text{assumption} \}$
  \begin{itemize}
    \item $\text{assignment} := (v := \varphi)$ s.t. $v \in V \land \varphi \in D_v \land \mathrm{var}(\varphi) \subseteq V$
    \item $\text{assumption} := [\varphi]$ s.t. $\varphi := \text{predicate} \land \mathrm{var}(\varphi) \subseteq V$
  \end{itemize}
\end{itemize}
\end{definition}

Evidently, a Control Flow Automaton (CFA) is a formalism based on graphs~\cite{Akos}.
Furthermore, assignment and assumption statements can be represented as transition functions, 
making them applicable in model checking.
\begin{align}
\mathrm{tran}\bigl(v := \varphi\bigr)
&\;=\;
\bigl(v' = \varphi\bigr)
\;\land\;
\bigwedge_{\,u \in V \setminus \{v\}} (u' = u),
\\
\mathrm{tran}\bigl([\psi]\bigr)
&\;=\;
\psi
\;\land\;
\bigwedge_{\,v \in V} (v' = v).
\end{align}

Although the validator we developed in Theta uses the concept of a Control Flow Automaton (CFA) as 
defined here, it actually employs an Extended Control Flow Automaton (XCFA). The XCFA is simply 
a more comprehensive version of a CFA designed to manage more intricate processes. However, in 
our current implementation, we don't utilize any of the additional capabilities offered by the XCFA.



\section{Product Automaton and Multianalysis}
Another formalism we'll need to understand is the Product Automaton. The intuition behind its 
importance lies in its ability to represent the combination of different formalism. We 
often model individual systems separately, but we need a way to understand their combined behavior, 
or what happens when these models interact in a defined manner. Informally, a Product 
Automaton is precisely this: the result of combining two formalisms. \texttt{Multianalysis}, then,
is the analysis performed on this resulting Product Automaton. While you can theoretically 
combine any two formalisms, in our specific case, we're interested in the product automaton 
of two (X)CFAs. The states of the combined system can be conceptualized as pairs, meaning the
state space is the Cartesian product of the states from the two individual automata.
Subsequently, it is necessary to define the transition rules between these product states.
Typically, these transitions depend on the properties of both automata and the
specified method of their combination. 
Section~\ref{sec:xcfa_product} details the construction of the product
automaton from the witness XCFA and the program XCFA. 

% Let the Program XCFA be $\mathcal{X}_P = (L_P, \text{Ops}_P, l_{P,0}, \mathcal{E}_P, \mathcal{V}_P)$, where:
% \begin{itemize} \itemsep0pt \parskip0pt \parsep0pt
%     \item $L_P$ is the set of locations.
%     \item $\text{Ops}_P$ is the set of operations (guards and assignments) on edges.
%     \item $l_{P,0} \in L_P$ is the initial location.
%     \item $\mathcal{E}_P \subseteq L_P \times \text{Ops}_P \times L_P$ is the set of edges.
%     \item $\mathcal{V}_P$ is the set of variables local to the program XCFA.
% \end{itemize}
% Let the Witness XCFA be $\mathcal{X}_W = (S_W, \text{Ops}_W, s_{W,0}, \mathcal{E}_W, \mathcal{V}_W)$, where:
% \begin{itemize} \itemsep0pt \parskip0pt \parsep0pt
%     \item $S_W$ is the set of locations (states).
%     \item $\text{Ops}_W$ is the set of operations on edges.
%     \item $s_{W,0} \in S_W$ is the initial location.
%     \item $\mathcal{E}_W \subseteq S_W \times \text{Ops}_W \times S_W$ is the set of edges.
%     \item $\mathcal{V}_W$ is the set of variables local to the witness XCFA.
% \end{itemize}
% Let $\mathcal{V}_{Expl}$ be the set of shared variables tracked explicitly in $\texttt{varsExpl}$.
% The global set of variables is $\mathcal{V}_{Global} = \mathcal{V}_P \cup \mathcal{V}_W \cup
% \mathcal{V}_{Expl} \cup \{\texttt{run}\}$.
% A valuation $\sigma$ maps variables in $\mathcal{V}_{Global}$ to their values.
% $\sigma(\texttt{varsExpl})$ denotes the current mapping of explicit shared variables.
%
% The \textbf{Product XCFA for Witness Validation}, denoted $\mathcal{X}_{Prod}$, is defined as
% $\mathcal{X}_{Prod} = (Q_{Prod}, \mathcal{V}_{Global}, q_{init}, \sigma_{init}, \mathcal{E}_{Prod})$
% where:
% \begin{itemize} \itemsep0pt \parskip0pt \parsep0pt
%     \item $Q_{Prod} = S_W \times L_P$. A product control location $(s,l)$ comprises a witness
%     location $s \in S_W$ and a program location $l \in L_P$.
%     \item $\mathcal{V}_{Global}$ is the set of all variables.
%     \item $q_{init} = (s_{W,0}, l_{P,0}) \in Q_{Prod}$ is the initial product control location.
%     \item $\sigma_{init}$ is the initial valuation:
%     \begin{itemize} \itemsep0pt \parskip0pt \parsep0pt
%         \item For $v \in \mathcal{V}_P \cup \mathcal{V}_W \cup \mathcal{V}_{Expl}$,
%         $\sigma_{init}(v)$ is undefined.
%         \item $\sigma_{init}(\texttt{varsExpl}) = \emptyset$.
%         \item $\sigma_{init}(\texttt{run})$ is undefined (effectively allowing the program XCFA
%         to proceed first, equivalent to $\texttt{run}=\text{false}$ for initial step choice).
%     \end{itemize}
%     \item $\mathcal{E}_{Prod} \subseteq Q_{Prod} \times \text{Guard} \times \text{Action} \times
%     Q_{Prod}$ is the set of product transitions. For an operation $\text{op}$ consisting of a guard
%     $[\phi]$ and assignments $\alpha$:
%     \begin{itemize} \itemsep0pt \parskip0pt \parsep0pt
%         \item \textbf{Witness XCFA Transitions}: For each $(s_i, ([\phi_W], \alpha_W), s_k) \in
%         \mathcal{E}_W$ and for every $l \in L_P$:
%         \[
%         \big( (s_i, l), [(\texttt{run} = \text{true}) \land \phi_W], \alpha_W, (s_k, l) \big)
%         \in \mathcal{E}_{Prod}
%         \]
%         The action $\alpha_W$ may update variables in $\mathcal{V}_W$, $\mathcal{V}_{Expl}$
%         (affecting $\texttt{varsExpl}$), and $\texttt{run}$.
%
%         \item \textbf{Program XCFA Transitions}: For each $(l_j, ([\phi_P], \alpha_P), l_m) \in
%         \mathcal{E}_P$ and for every $s \in S_W$:
%         \[
%         \big( (s, l_j), [(\texttt{run} = \text{false} \lor \texttt{run} = \text{undefined}) \land
%         \phi_P], \alpha_P, (s, l_m) \big) \in \mathcal{E}_{Prod}
%         \]
%         The action $\alpha_P$ may update variables in $\mathcal{V}_P$, $\mathcal{V}_{Expl}$
%         (affecting $\texttt{varsExpl}$), and $\texttt{run}$.
%     \end{itemize}
% \end{itemize}
% A configuration of the analysis is $(q, \sigma)$, where $q \in Q_{Prod}$ and $\sigma$ is the current
% global valuation. The set $\texttt{states}$ maintained by the analysis stores such configurations,
% focusing on $\sigma(\texttt{varsExpl})$ for explicit values.

% More precisely:
% \begin{definition}[Product Automaton of CFA's]
% Given two CFAs:
% \begin{itemize}
%     \item $\text{CFA}_1 = (V_1, L_1, l_{0_1}, E_1)$
%     \item $\text{CFA}_2 = (V_2, L_2, l_{0_2}, E_2)$
% \end{itemize}
% with $V_1 \cap V_2 = \emptyset$ (disjoint variables), their \textbf{product automaton} is defined as:
% \[
% \text{CFA}_1 \times \text{CFA}_2 = (V, L, l_0, E)
% \]
% where:
% \begin{itemize}
%     \item $V = V_1 \cup V_2$ (combined variables)
%     \item $L = L_1 \times L_2$ (product locations: pairs $(l_1, l_2)$ where $l_1 \in L_1, l_2 \in L_2$)
%     \item $l_0 = (l_{0_1}, l_{0_2})$ (initial location)
%     \item $E \subseteq L \times \mathrm{Ops} \times L$ (transitions defined below)
% \end{itemize}
%
% \noindent The edge set $E$ is constructed as follows:
% \begin{itemize}
%     \item \textbf{Synchronized transitions}:
%     \begin{itemize}
%         \item For edges $(l_1, [\varphi_1], l_1') \in E_1$ and $(l_2, [\varphi_2], l_2') \in E_2$:
%         \[
%         \big((l_1, l_2), [\varphi_1 \land \varphi_2], (l_1', l_2')\big) \in E \quad \text{if } \varphi_1 \land \varphi_2 \text{ is satisfiable}
%         \]
%         \item For $(l_1, (v := \varphi), l_1') \in E_1$ and $(l_2, [\psi], l_2') \in E_2$:
%         \[
%         \big((l_1, l_2), (v := \varphi), (l_1', l_2)\big) \in E \quad \text{if } \psi \text{ holds after the assignment}
%         \]
%         (Analogously for assignments in $\text{CFA}_2$ and assumptions in $\text{CFA}_1$)
%     \end{itemize}
%     
%     \item \textbf{Interleaved transitions}:
%     \begin{itemize}
%         \item For any edge $(l_1, \mathrm{op}, l_1') \in E_1$:
%         \[
%         \big((l_1, l_2), \mathrm{op}, (l_1', l_2)\big) \in E \quad \forall l_2 \in L_2
%         \]
%         \item For any edge $(l_2, \mathrm{op}, l_2') \in E_2$:
%         \[
%         \big((l_1, l_2), \mathrm{op}, (l_1, l_2')\big) \in E \quad \forall l_1 \in L_1
%         \]
%     \end{itemize}
% \end{itemize}
% \end{definition}


% https://ftsrg.mit.bme.hu/phd-thesis-hajdua/dissertation.pdf
% page 1
% page 46 control flow automata
% https://link.springer.com/chapter/10.1007/978-3-031-66149-5_11
% Stair, Ralph M. (2003). Principles of Information Systems, Sixth Edition. Thomson. p. 16. ISBN 0-619-06489-7. "Software consists of computer programs that govern the operation of the computer."

